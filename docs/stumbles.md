# 困った事など

## 線が上手く読み取れない

線を読み取るために、画像を 2 値化する (白と黒の単純な画像にする) が、その閾値によっては背景の模様を線として読み取ってしまったり、もしくは線を上手く読み取ってくれなかったりする。

これについては、解決方法が存在しないため、実際の実行結果を見ながら閾値を調整していく必要がある。今回のプログラムでは、`config.ini` の `threshold` という変数を書き変えることで閾値を調整することができる。

実際に稼動させる上では、いちいち人間的に閾値を変えることは現実的ではない (人件費が発生してしまう) ため、走行環境に合わせて自ら閾値を変更していく必要があるが、様々な環境を走らせて学習をしていく必要があり、非常に長い期間と手間を掛ける必要がある。

## opencv-python のインストールが終わらない

~~画像解析などを行うために、`OpenCV` と呼ばれるパッケージが必要になる。そのため、`pip3 install opencv-python` を実行して必要なモジュールをインストールするのだが、インストール中に内部で OpenCV 関連のソースコードをコンパイルしているので、それを Raspberry Pi 上で実行すると非常に時間が掛かる。~~

この問題は、piwheels の提供するコンパイル済みの wheels を使用することで解決できる。何らかの理由で piwheels のリポジトリが上手く参照されなかったことが原因と思われる。

### 解決方法

~~Raspberry Pi OS のソフトウェアリポジトリにコンパイル済みの `opencv-python` が用意されているので、それを利用する。~~

Python のような言語において、GNU/Linux ディストリビューションの提供するライブラリパッケージを使用するのはあまり効果的ではない。多少時間が掛かっても `pip` でインストールすべきだ。

## OpenCV がエラーを吐く

OpenCV と web カメラの相性が悪いのか、`Corrupt JPEG data:` から始まるエラー文をずっと出力するため、使用者の混乱を招く可能性がある。

### 使用した workaround

これは OpenCV 側の問題であり、Python のコードを修正することで対処できる問題ではないため、今回は起動用スクリプトを用意し、その中でエラーを表示させないことで対処した。**これは本質的な解決ではないため、あくまで一時的な対処として使用すべきである。**

```
#!/bin/bash

unbuffer python3 src/main.py |& grep --line-buffered -v "Corrupt JPEG data:"
```

このスクリプトを実行するためには、`expect` というパッケージが必要になる。

```
# apt install expect
```

-   出典: [python - OpenCV error on Raspbian: Corrupt jpeg data: 1 extraneous bytes before marker 0xd6 - Stack Overflow](https://stackoverflow.com/questions/42931346/)

## 画面を繋がずにプログラムを実行するとフリーズする

画面を繋がずに Python のプログラムを実行 (SSH 経由) すると、全く入力を受け付けない状態になってしまう。原因が分からないため、テスト時点では画面に接続した状態で実行する必要がある。

### 原因, 回避策

システム上で使用されている GPIO ピンを操作しようとするとフリーズする事が分かった。GPIO 出力を行うためには、システムが使っていない比較的若い番号のピンに接続する必要がある。今回は、そのトラブルを防ぎ、接続を簡略化するために USB 経由でシリアル通信を行うことにした。

## モバイルバッテリーからの電力の供給が安定しない

モバイルバッテリーから、モーター等を駆動させる電源を取るが、その電流 (電圧?) が安定せず、モーターが止まってしまう場合がある。テスト時点では、モバイルバッテリーではなく、コンセント等から供給して対処しているが、単体稼動させる際に、バッテリーをどうするのかはしっかり検討する必要がある。

## シリアル通信の遅延が大きい

コードを改良する前の時点で、操作してから実際に動くまでに約2秒の遅延があった。

### 原因, 対処

Arduino 上で文字列を扱うと処理に時間がかかってしまうことがわかった。そのため、送られたデータを文字列として扱うのではなく、byte 型で送られたまま処理することで、全体の処理速度を大幅に上げることに成功した (2秒→0.5秒)。

そのためには、Arduino と Python 両方のプログラムに変更が必要になった。明示的に pySerial で byte 型のデータを送る方法が少し分かりにくいため、下に例を示す。

```py
import serial

# シリアル通信
arduino = serial.Serial(port='/dev/ttyACM0', baudrate=115200)

# 53 (16進数) => 83 (10進数)
# 83 はアルファベットの 'S' を意味するが、別にこの数字に拘る必要は無い
arduino.write(b'\x53')

arduino.flush()
arduino.close()
```
